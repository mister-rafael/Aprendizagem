# Este arquivo é como uma lista de ingredientes e o modo de preparo para o Docker.
services:
  # Serviço de API
  api:
    # Em vez de 'image', usamos 'build: .'. Isso diz ao Compose para
    # construir uma imagem usando o Dockerfile que está nesta pasta.
    build: .
    container_name: guru_api_app
    ports:
      # Mapeia a porta 3333 da nossa máquina para a porta 3333 do contêiner.
      - "3333:3333"
    env_file:
      - .env.docker
    # Garante que o contêiner do banco de dados (db) suba ANTES do da api.
    depends_on:
      - db
    # Este é o nome do nosso serviço/contêiner
  db:
    # A imagem que queremos usar. Estamos pegando a versão 16 do Postgres.
    image: postgres:16
    # O nome que daremos ao contêiner depois que ele for criado.
    container_name: postgres_db_guru
    # Reinicia o contêiner automaticamente se ele parar.
    restart: always
    # Aqui definimos as variáveis de ambiente para o banco de dados.
    # IMPORTANTE: Em um projeto real, nunca coloque senhas diretamente aqui.
    # Usaríamos arquivos .env, mas para didática, vamos simplificar.
    environment:
      - POSTGRES_USER=guru
      - POSTGRES_PASSWORD=guru_password
      - POSTGRES_DB=guru_api
    # Mapeia a porta 5432 do contêiner para a porta 5432 da sua máquina.
    # Assim, nossa aplicação Node.js poderá se conectar ao banco.
    ports:
      - "5432:5432"
    # O volume garante que os dados do seu banco não sejam perdidos
    # se o contêiner for recriado. Ele mapeia uma pasta no seu computador
    # para a pasta de dados dentro do contêiner.
    volumes:
      # nome do volume é gerenciado pelo Docker, uma prática um pouco melhor.
      - pgdata:/var/lib/postgresql/data

# O Docker gerencia o volume para nós.
volumes:
  pgdata: # <-- Aqui estamos "declarando" a existência do armário.
